<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="dark light" />
    <title>Flappy Bird (Canvas)</title>
    <style>
      :root {
        --bg-start: #6ad0ff;
        --bg-end: #dff6ff;
        --text: #0b1426;
        --pipe: #2ecc71;
        --pipe-dark: #27ae60;
        --ground: #c07a3f;
        --ground-dark: #a4612d;
        --bird: #ffd166;
        --bird-dark: #f5a836;
      }

      * { box-sizing: border-box; }

      html, body {
        height: 100%;
        margin: 0;
      }

      body {
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, var(--bg-start), var(--bg-end));
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
      }

      .game-wrapper {
        position: relative;
        width: min(92vw, 520px);
        aspect-ratio: 3 / 4;
        max-height: 92vh;
        border-radius: 16px;
        box-shadow: 0 12px 40px rgba(0,0,0,0.18), inset 0 0 0 1px rgba(0,0,0,0.08);
        overflow: hidden;
        background: transparent;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: transparent;
      }

      .hud {
        position: absolute;
        top: 10px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        padding: 0 14px;
        pointer-events: none;
        mix-blend-mode: multiply;
      }

      .chip {
        background: rgba(255,255,255,0.75);
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        border-radius: 999px;
        padding: 6px 12px;
        font-weight: 700;
        letter-spacing: 0.4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 16px;
        pointer-events: none;
      }

      .overlay-inner {
        background: rgba(255,255,255,0.82);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        border-radius: 16px;
        padding: 18px 20px;
        max-width: 90%;
        box-shadow: 0 20px 60px rgba(0,0,0,0.2);
        pointer-events: auto;
      }

      .title {
        margin: 0 0 8px;
        font-size: clamp(18px, 3.6vw, 24px);
      }

      .subtitle {
        margin: 0 0 6px;
        font-size: clamp(14px, 2.8vw, 16px);
        opacity: 0.85;
      }

      .hint {
        margin-top: 8px;
        font-size: clamp(12px, 2.6vw, 14px);
        opacity: 0.8;
      }

      .btn {
        display: inline-block;
        margin-top: 10px;
        background: var(--bird);
        color: #000;
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        font-weight: 800;
        letter-spacing: 0.5px;
        cursor: pointer;
        box-shadow: 0 6px 16px rgba(0,0,0,0.25);
        text-transform: uppercase;
      }

      .btn:active { transform: translateY(1px); }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0,0,0,0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <div class="game-wrapper" id="game">
      <div class="hud">
        <div class="chip" id="scoreChip">Score: 0</div>
        <div class="chip" id="bestChip">Best: 0</div>
      </div>
      <canvas id="canvas" width="480" height="640" aria-label="Flappy Bird Game Area"></canvas>
      <div class="overlay" id="overlay" aria-live="polite">
        <div class="overlay-inner">
          <h2 class="title" id="overlayTitle">Flappy Bird</h2>
          <p class="subtitle" id="overlaySubtitle">Tap, click, or press Space to flap</p>
          <p class="hint">Avoid the pipes. Pass through gaps to score.</p>
          <button class="btn" id="overlayButton" type="button">Play</button>
        </div>
      </div>
    </div>

    <script>
      (function () {
        const CONFIG = {
          logicalWidth: 480,
          logicalHeight: 640,
          groundHeight: 96,
          gravity: 1200,
          flapImpulse: 480,
          maxFallSpeed: 900,
          pipeSpeed: 120,
          pipeGap: 220,
          pipeWidth: 70,
          pipeIntervalSec: 1.8,
          birdX: 120,
          birdRadius: 14,
          cloudCount: 6
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlaySubtitle = document.getElementById('overlaySubtitle');
        const overlayButton = document.getElementById('overlayButton');
        const scoreChip = document.getElementById('scoreChip');
        const bestChip = document.getElementById('bestChip');

        let deviceScale = 1;
        let lastTimestampMs = 0;
        let accumulatedSpawnSec = 0;

        const gameState = {
          mode: 'ready', // 'ready' | 'playing' | 'gameover'
          score: 0,
          best: Number(localStorage.getItem('flappy-best') || 0),
          birdY: CONFIG.logicalHeight * 0.45,
          birdV: 0,
          pipes: [],
          groundOffset: 0,
          clouds: []
        };

        function updateHud() {
          scoreChip.textContent = `Score: ${gameState.score}`;
          bestChip.textContent = `Best: ${gameState.best}`;
        }

        function resizeCanvasForDpr() {
          const dpr = window.devicePixelRatio || 1;
          deviceScale = dpr;
          canvas.width = CONFIG.logicalWidth * dpr;
          canvas.height = CONFIG.logicalHeight * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function resetGame() {
          gameState.mode = 'ready';
          gameState.score = 0;
          gameState.birdY = CONFIG.logicalHeight * 0.45;
          gameState.birdV = 0;
          gameState.pipes = [];
          gameState.groundOffset = 0;
          accumulatedSpawnSec = 0;
          seedClouds();
          updateHud();
          showOverlay('Flappy Bird', 'Tap, click, or press Space to flap', 'Play');
        }

        function startGame() {
          gameState.mode = 'playing';
          overlay.style.display = 'none';
        }

        function endGame() {
          gameState.mode = 'gameover';
          if (gameState.score > gameState.best) {
            gameState.best = gameState.score;
            localStorage.setItem('flappy-best', String(gameState.best));
          }
          updateHud();
          showOverlay('Game Over', `Score: ${gameState.score} Â· Best: ${gameState.best}`, 'Restart');
        }

        function showOverlay(title, subtitle, buttonText) {
          overlayTitle.textContent = title;
          overlaySubtitle.textContent = subtitle;
          overlayButton.textContent = buttonText;
          overlay.style.display = 'grid';
        }

        function seedClouds() {
          gameState.clouds = Array.from({ length: CONFIG.cloudCount }).map(() => ({
            x: Math.random() * CONFIG.logicalWidth,
            y: Math.random() * (CONFIG.logicalHeight - CONFIG.groundHeight - 240),
            r: 14 + Math.random() * 24,
            s: 8 + Math.random() * 18
          }));
        }

        function spawnPipePair() {
          const usableHeight = CONFIG.logicalHeight - CONFIG.groundHeight;
          const gap = CONFIG.pipeGap;
          const minTop = 40;
          const maxTop = usableHeight - gap - 60;
          const topHeight = minTop + Math.random() * (maxTop - minTop);
          const pipeX = CONFIG.logicalWidth + CONFIG.pipeWidth;
          gameState.pipes.push({
            x: pipeX,
            width: CONFIG.pipeWidth,
            topHeight,
            gap,
            scored: false
          });
        }

        function handleFlap() {
          if (gameState.mode === 'ready') {
            startGame();
          }
          if (gameState.mode === 'playing') {
            gameState.birdV = -CONFIG.flapImpulse;
          }
          if (gameState.mode === 'gameover') {
            resetGame();
          }
        }

        function update(dt) {
          if (gameState.mode === 'playing') {
            gameState.birdV = Math.min(gameState.birdV + CONFIG.gravity * dt, CONFIG.maxFallSpeed);
            gameState.birdY += gameState.birdV * dt;

            accumulatedSpawnSec += dt;
            if (accumulatedSpawnSec >= CONFIG.pipeIntervalSec) {
              accumulatedSpawnSec = 0;
              spawnPipePair();
            }

            const deltaX = CONFIG.pipeSpeed * dt;
            for (let i = 0; i < gameState.pipes.length; i++) {
              gameState.pipes[i].x -= deltaX;
            }

            gameState.pipes = gameState.pipes.filter(p => p.x + p.width > -32);

            gameState.groundOffset = (gameState.groundOffset + deltaX) % 48;

            // Scoring and collisions
            const birdX = CONFIG.birdX;
            const r = CONFIG.birdRadius;
            const birdTop = gameState.birdY - r;
            const birdBottom = gameState.birdY + r;

            for (const pipe of gameState.pipes) {
              const inPipeX = birdX + r > pipe.x && birdX - r < pipe.x + pipe.width;
              const gapTop = pipe.topHeight;
              const gapBottom = pipe.topHeight + pipe.gap;

              if (inPipeX && (birdTop < gapTop || birdBottom > gapBottom)) {
                endGame();
                break;
              }

              if (!pipe.scored && pipe.x + pipe.width < birdX - r) {
                pipe.scored = true;
                gameState.score += 1;
                updateHud();
              }
            }

            const ceiling = 0;
            const groundY = CONFIG.logicalHeight - CONFIG.groundHeight;
            if (gameState.birdY - r <= ceiling || gameState.birdY + r >= groundY) {
              endGame();
            }
          }
        }

        function drawBackground() {
          const w = CONFIG.logicalWidth;
          const h = CONFIG.logicalHeight;

          // Sky gradient under UI
          const grad = ctx.createLinearGradient(0, 0, 0, h);
          grad.addColorStop(0, '#86e0ff');
          grad.addColorStop(1, '#f2fbff');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);

          // Clouds
          for (const cloud of gameState.clouds) {
            cloud.x -= (5 + cloud.s * 0.08) / 60; // slow drift independent of dt for subtle motion
            if (cloud.x < -cloud.r * 3) cloud.x = w + cloud.r * 3;
            drawCloud(cloud.x, cloud.y, cloud.r);
          }
        }

        function drawCloud(x, y, r) {
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.arc(x + r * 0.9, y + r * 0.1, r * 0.8, 0, Math.PI * 2);
          ctx.arc(x - r * 0.8, y + r * 0.2, r * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }

        function drawPipes() {
          for (const pipe of gameState.pipes) {
            const x = pipe.x;
            const w = pipe.width;
            const topH = pipe.topHeight;
            const bottomY = pipe.topHeight + pipe.gap;
            const groundY = CONFIG.logicalHeight - CONFIG.groundHeight;

            // Top pipe
            drawPipeRect(x, 0, w, topH);
            // Bottom pipe
            drawPipeRect(x, bottomY, w, groundY - bottomY);
          }
        }

        function drawPipeRect(x, y, w, h) {
          ctx.fillStyle = '#2ecc71';
          ctx.fillRect(x, y, w, h);
          ctx.fillStyle = '#27ae60';
          ctx.fillRect(x + 6, y, 8, h);
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x + w - 10, y, 6, h);
        }

        function drawGround() {
          const groundY = CONFIG.logicalHeight - CONFIG.groundHeight;
          ctx.fillStyle = '#c07a3f';
          ctx.fillRect(0, groundY, CONFIG.logicalWidth, CONFIG.groundHeight);

          // Simple repeating pattern to fake parallax ground movement
          ctx.fillStyle = '#a4612d';
          const tileW = 48;
          const tileH = 24;
          const offset = gameState.groundOffset % tileW;
          for (let x = -tileW + offset; x < CONFIG.logicalWidth + tileW; x += tileW) {
            ctx.fillRect(x, groundY, tileW * 0.6, tileH);
          }
        }

        function drawBird() {
          const x = CONFIG.birdX;
          const y = gameState.birdY;
          const r = CONFIG.birdRadius;

          // Body
          const tilt = Math.max(-0.6, Math.min(0.6, gameState.birdV / CONFIG.maxFallSpeed * 1.2));
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(tilt);
          ctx.fillStyle = '#ffd166';
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.fill();

          // Wing
          ctx.fillStyle = '#f5a836';
          ctx.beginPath();
          ctx.ellipse(-2, 2, r * 0.7, r * 0.4, -0.5, 0, Math.PI * 2);
          ctx.fill();

          // Eye
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(r * 0.35, -r * 0.2, r * 0.32, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(r * 0.48, -r * 0.2, r * 0.12, 0, Math.PI * 2);
          ctx.fill();

          // Beak
          ctx.fillStyle = '#ff9f1c';
          ctx.beginPath();
          ctx.moveTo(r * 0.9, 0);
          ctx.lineTo(r * 1.5, -r * 0.2);
          ctx.lineTo(r * 1.5, r * 0.2);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }

        function drawScore() {
          if (gameState.mode === 'playing') {
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
            ctx.textAlign = 'center';
            ctx.fillText(String(gameState.score), CONFIG.logicalWidth / 2, 54);
          }
        }

        function loop(timestampMs) {
          if (!lastTimestampMs) lastTimestampMs = timestampMs;
          const dt = Math.min(0.033, (timestampMs - lastTimestampMs) / 1000);
          lastTimestampMs = timestampMs;

          update(dt);

          ctx.clearRect(0, 0, CONFIG.logicalWidth, CONFIG.logicalHeight);
          drawBackground();
          drawPipes();
          drawGround();
          drawBird();
          drawScore();

          requestAnimationFrame(loop);
        }

        function onKey(e) {
          if (e.code === 'Space' || e.code === 'ArrowUp') {
            e.preventDefault();
            handleFlap();
          }
          if (e.code === 'Enter' && gameState.mode === 'gameover') {
            e.preventDefault();
            resetGame();
          }
        }

        function onPointerDown(e) {
          handleFlap();
        }

        function onVisibilityChange() {
          if (document.hidden && gameState.mode === 'playing') {
            // Soft pause animation effects by zeroing last timestamp so delta doesn't spike
            lastTimestampMs = 0;
          }
        }

        overlayButton.addEventListener('click', () => {
          if (gameState.mode === 'ready') startGame();
          else if (gameState.mode === 'gameover') resetGame();
        });

        window.addEventListener('keydown', onKey, { passive: false });
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('touchstart', onPointerDown, { passive: true });
        document.addEventListener('visibilitychange', onVisibilityChange);

        // Initial setup
        resizeCanvasForDpr();
        window.addEventListener('resize', resizeCanvasForDpr);
        updateHud();
        resetGame();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
